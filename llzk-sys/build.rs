//! llzk-sys's build script.
//!
//! Performs the following sequence of steps:
//! - Build and link the vendored version of `llzk-lib`
//! - Generate the Rust bindings for LLZK's CAPI using [`bindgen`].
//! - Build and link the static functions defined in LLZK's CAPI.

use anyhow::Result;
use llzk_sys_build_support::{
    build_llzk,
    config_traits::{bindgen::BindgenConfig as _, cc::CCConfig as _},
    default::DefaultConfig,
    wrap_static_fns::WrapStaticFns,
};
use std::{env, path::Path};

/// Default configuration of the build process.
///
/// Exported names on LLZK's CAPI are usually prefixed with `Llzk` or `llzk`. However, some names
/// in the CAPI are prefixed with `Mlir` or `mlir`. These include:
///
/// - LLZK's passes since its CAPI is generated with tablegen and that's the prefix used by the
///   tool.
/// - LLZK's functions for dialect handles and pass registration. These are also generated by
///   tablegen.
/// - Helper types whose corresponding C++ type is a MLIR type.
fn create_default_cfg() -> DefaultConfig<'static> {
    let mut passes = vec![
        "ArrayToScalar",
        "InlineIncludes",
        "Flattening",
        "RedundantOperationElimination",
        "RedundantReadAndWriteElimination",
        "UnusedDeclarationElimination",
        "MemberWriteValidator",
    ];
    let pcl_enabled = env::var_os("CARGO_FEATURE_PCL_BACKEND").is_some();
    if pcl_enabled {
        passes.push("PCLLowering");
    }

    DefaultConfig::new(
        pcl_enabled,
        passes,
        &[
            "GetDialectHandle__llzk__.*",
            "Operation.*",
            "OpBuilder.*",
            "RegisterLLZK.*Passes",
            "RegisterPCL.*Passes",
        ],
        &[
            "OpBuilder",
            "OpBuilderListener",
            "Notify(Operation|Block)Inserted",
            "(Op|Block)BuilderInsertPoint",
            "ValueRange",
        ],
    )
}

fn run() -> Result<()> {
    let out_dir = env::var("OUT_DIR")?;
    let default_cfg = create_default_cfg();
    default_cfg.emit_cargo_commands()?;
    let cfg = (
        &default_cfg,
        WrapStaticFns::new(Path::new(&out_dir)),
        build_llzk(Path::new("llzk-lib"), &default_cfg)?,
    );
    cfg.generate()?
        .write_to_file(Path::new(&out_dir).join("bindings.rs"))?;
    cfg.try_compile("llzk-sys-cc")
}

fn main() {
    if let Err(err) = run() {
        println!("cargo:error={err:#}");
        std::process::exit(1);
    }
}
